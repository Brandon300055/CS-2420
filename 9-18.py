def countingSort(A):
    #self.compares = len(A)
    #self.swape = len(A)
    F = [0] * len(A)
    for v in A:
        F[V]+=1
        SL = []
        K = 0
        for i in range(len(F)):
            count = F[i]
            value = 1
            for i in range(count):
                A.append(value)


    # def countSort(self, A):
    #     maximum = max(A)
    #     minimum = min(A)
    #     count_array = [0]*(maximum-minimum+1)
    #
    #     for val in A:
    #         count_array[val-minimum] += 1
    #
    #         sorted_array = []
    #         for i in range(minimum, maximum+1):
    #             if count_array[i-minimum] > 0:
    #                 for j in range(0, count_array[i-minimum]):
    #                     sorted_array.append(i)



    #2^nuber of verbales


    #always add a commpage
    #data copy = data swaps

    #                    self.swaps+=1
    #                    A[k]=lefthalf[i]

#dont compare


    def quickSort (self, A, low, high):
        #bace case
        if (high - low <= 0):
            return

        if mod:
            return
        else:
            mid = (low+1)

    #left moust something
        pivot = low
        lmgt = low + 1

        #low plus 1 plus high
        for i in range(low+1,high+1):
            if A[i] < A[low]:
                A[i], A[lmgt] = A[lmgt], A[i]

        # #recursen
        # def quickSort(A, low, ( + 1)):
